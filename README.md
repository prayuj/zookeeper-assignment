<p>you are a zookeeper at the local zoo. work is hard! pay is lousy, and all you do is shovel poop! to make up for it the zoo pays for lunch, but all of you must go to lunch together. fortunately, the zoo uses ZooKeeper!</p>
<p>there is a designated znode in ZooKeeper for lunch. In this example, we will call it <strong>/lunch</strong>. (you will take the znode path as a command line parameter.) when it is time for lunch, the supervisor will create a znode called <strong>/lunch/readyforlunch</strong> which indicates that the zookeepers should get cleaned up and ready for lunch. it is also the time for zookeepers to figure out who is going to pick the place to go. once the shuttle is ready to take the zookeepers to lunch, the supervisor will create a znode called <strong>/lunch/lunchtime</strong>. at which point, the lunch leader decide where to go to lunch and who is going.</p>
<p>the supervisor will call the <strong>goingToLunch()</strong> method of the <strong>ZooLunch</strong> gRPC service on the lunch leader to find out who is going to lunch and where. sometimes the supervisor gets confused, so if <strong>goingToLunch()</strong> is called on an non-lunch leader, the appropriate return code should be returned.</p>
<p>the zoo also has an auditor to make sure lunches are billed correctly. the auditor uses two calls to do audits: <strong>lunchesAttended()</strong> to get the zxids of the /lunchtime znodes of the lunches attended and <strong>getLunch()</strong> that will return information about the lunch.</p>
<p>only zookeepers that registered their znodes before the <strong>/lunch/lunchtime</strong> znode and after <strong>/lunch/readyforlunch </strong>will be able to go to lunch. zookeepers that attend a lunch must persistently record it so that they can produce information for auditors even if they are restarted.</p>
<h2>attendance and choosing the leader</h2>
<p>the leader will need to know all the zookeepers that go to lunch, so all available zookeepers will create an emphemeral znode of the form <strong>/lunch/zk-&lt;zookeeper_name&gt;</strong> (use _ for spaces). zookeepers will create their znode when the <strong>/lunch/readyforlunch</strong> appears and will delete their znode when<strong> /lunch/lunchtime</strong> disappears.</p>
<p>zookeepers use an ephemeral node in <strong>/lunch/leader</strong> to choose a leader. the zookeeper who is able to create that znode will be the leader. the content of that znode will be the name of the leader. zookeeping can be a dangerous job, so sometimes an leader has to miss lunch. when that happens (the zookeeper process crashes), another zookeeper should grab leadership.</p>
<p>zookeepers are a rather polite group, so they try to take turns. if they are a lunch leader, they remember how many people attended lunch with them and sleep that many seconds before trying to become leader the next time. if they are not able to become leader the next time, they will sleep one minus the previous number of seconds the next time they try to become leader, and so on. for example, a leader of 3 zookeepers, will sleep 3 seconds the next time they have an opportunity to become leader. 2 seconds the time after that (assuming they don't become leader). 1 second after that, and then no delay from then on until they become leader again.</p>
<h2>gRPC ZooLunch service</h2>
<p>this lunch perk is pretty expense, so management wants to ensure there is no fraud. all zookeepers must create an ephemeral znode in <strong>/lunch/employee/zk-&lt;zookeeper_name&gt; </strong>it is kind of the company directory. the content of each of the files is the <strong>host:port </strong>of the gRPC audit server used by that zookeeper.</p>
<p>the service has the following form:</p>
<pre>syntax = "proto3";<br>package edu.sjsu.cs249.zooleader;<br>service ZooLunch {<br>&nbsp; &nbsp;// request an audit of the last or current lunch situation<br>  &nbsp;rpc goingToLunch(GoingToLunchRequest) returns (GoingToLunchResponse) {}<br>&nbsp; &nbsp;// request an audit of the last or current lunch situation<br>   rpc lunchesAttended(LunchesAttendedRequest) returns (LunchesAttendedResponse) {}<br>&nbsp; &nbsp;// request an audit of the last or current lunch situation<br>  &nbsp;rpc getLunch(GetLunchRequest) returns (GetLunchResponse) {}<br>  &nbsp;// skip the next readyforlunch announcement<br>&nbsp; &nbsp;rpc skipLunch(SkipRequest) returns (SkipResponse) {}<br>&nbsp; &nbsp;// exit your process right away<br>  &nbsp;rpc exitZoo(ExitRequest) returns (ExitResponse) {}<br>}<br><br>message GoingToLunchRequest {}<br>// the Audit Response is always about the current lunch or last lunch if no lunch is getting ready<br>message GoingToLunchResponse {<br>   int32 rc = 1; // 0 - if current lunch leader, 1 - if not current lunch leader<br>   // the following are set only if rc == 0<br>   string restaurant = 2; // the name of the restaurant<br>  &nbsp;string leader = 3; // the zk-&lt;name&gt; of the leader<br>  &nbsp;repeated string attendees = 4; // the zk-&lt;name&gt; of the attendees<br>}<br><br>message LunchesAttendedRequest {}<br>message LunchesAttendedResponse {<br>    repeated int64 zxids = 1; // zxid of the /lunchtime of lunches attended<br>}<br><br>message GetLunchRequest {<br>    int64 zxid = 1; // zxid of the /lunchtime of lunch to query<br>}<br>message GetLunchResponse {<br>    int32 rc = 1; // 0 - if was lunch leader, 1 - if attended only, 2 - if didn't attend<br>    string leader = 2; // the zk-&lt;name&gt; of the leader if rc == 0 or 1<br> &nbsp; &nbsp;// the following are set only if rc == 0<br>    string restaurant = 3; // the name of the restaurant<br>    repeated string attendees = 4; // the zk-&lt;name&gt; of the attendees<br>}<br><br>message SkipRequest {}<br>message SkipResponse {}<br>message ExitRequest {}<br>message ExitResponse {}</pre>
<h2>working with zookeeper</h2>
<p>you will need to add the following dependency in your pom.xml file for zookeeper:</p>
<pre><span>&lt;dependency&gt;<br></span><span>    &lt;groupId&gt;</span>org.apache.zookeeper<span>&lt;/groupId&gt;<br></span><span>    &lt;artifactId&gt;</span>zookeeper<span>&lt;/artifactId&gt;<br></span><span>    &lt;version&gt;</span>3.7.1<span>&lt;/version&gt;<br></span><span>&lt;/dependency&gt;</span></pre>
<p><br>most of the calls are pretty simple. you can construct a ZooKeeper client that simply prints any watch events it receives with:</p>
<pre>ZooKeeper zk = new ZooKeeper(zookeeper_server_list, 10000, (e) -&gt; {System.out.println(e)});
</pre>
<p>to create a znode use the OPEN_ACL_UNSAFE constant:</p>
<pre>zk.create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL)
</pre>
<p>you can use the zookeeper servers at zookeeper.class.homeofcode.com (that name actually resolves to three addresses) or you can run your own locally with java -jar <span class="ally-file-link-holder link_holder"><span class="instructure_file_holder link_holder instructure_file_link_holder"><a class="inline_disabled" title="zookeeper-dev-fatjar.jar" href="https://drive.google.com/file/d/1SOXY1pHT6C31nZT8SxohvZ03wXrJ6pdW/view?usp=drive_link" target="_blank" data-canvas-previewable="false" data-api-endpoint="https://sjsu.instructure.com/api/v1/courses/1557174/files/71921241" data-api-returntype="File" data-id="71921241">zookeeper-dev-fatjar.jar</a></span></span> server 2181 data (which will create a data subdirectory and listen on 127.0.0.1:2181).</p>
<h2>command line</h2>
<p>your program should take the following commandline:</p>
<pre>java -jar zooleader.jar your_name grpcHostPort zookeeper_server_list lunch_path</pre>
<h2>submission</h2>
<ul>
<li aria-level="1"><span>Submit a zipped file with your <strong>pom.xml</strong> and /src directory containing all your <strong>.java files</strong>&nbsp;<br></span></li>
</ul>
<p><span>Keep both in the root of the zip file. DO NOT include both in a folder and compress the folder itself.</span></p>
<h2><span>note</span></h2>
<p><span>Do not make any changes in the proto file and do not rename the proto file.</span></p>